import flash.display.StageDisplayState;import fl.controls.Button;import fl.events.SliderEvent;import flash.events.MouseEvent;import com.whtn.*;import flash.events.ActivityEvent; import flash.events.StatusEvent; import flash.media.Microphone;var globalSpeed = 120;var myFormat:TextFormat = new TextFormat();	myFormat.font = "_sans";	myFormat.size = 10;	myFormat.color = 0xFFFFFF;function _trace (o:Object) {	msg = (o is DebugEvent) ? o.msg : o;	trace(msg);	myConsole.text = msg+"\n"+myConsole.text;}String.prototype.titleCase = function (_input:String=null) {	inputString = (_input==null)?this:_input;	return inputString.split(" ").map(function(element:String, index:int, arr:Array):String{		return element.substr(0, 1).toLocaleUpperCase() + element.substr(1);	}).join(" ");}function goFullScreen(event:Event):void{	if (stage.displayState == StageDisplayState.FULL_SCREEN) {		stage.removeEventListener(Event.ENTER_FRAME,_handleEnterFrame);		trace(stage.displayState);	} else {		stage.displayState=StageDisplayState.FULL_SCREEN;	}}//stage.addEventListener(Event.ENTER_FRAME, goFullScreen)goFullScreen(new Event('foo'));var engine:Engine = new Engine();//var sequencer:Sequencer = new Sequencer();var phidget:Phidgets = new Phidgets();//------------------------------------------------------// INTERFACESvar sn1 = new SN1UI();	sn1.x = 600;	sn1.y = 0;	sn1.name = "sn1";
//	sn1.visible = false;addChild(sn1);var mj1 = new MJ1UI();	mj1.x = 10;	mj1.y = 200;	mj1.name = "mj1";addChild(mj1);//------------------------------------------------------//EVENT ROUTING... because databinding is a chore//route manual commands from the UI to the devicemj1.addEventListener("tube",phidget.listener);sn1.addEventListener("light",phidget.listener);//route commands from the animator to the devicesengine.addEventListener("light",phidget.listener);engine.addEventListener(TubeEvent.TUBE,phidget.listener);//route commands from the animator to the UIengine.addEventListener("light",sn1.update);engine.addEventListener(TubeEvent.TUBE,mj1.update);//route commands between the engine & sequencerengine.addEventListener( EffectEvent.EFFECT, sn1.sequencer.listener);engine.addEventListener( EffectEvent.EFFECT, mj1.sequencer.listener);
engine.addEventListener("blackout",phidget.blackout);engine.addEventListener("blackout",mj1.blackout);
mj1.sequencer.addEventListener( EffectEvent.EFFECT ,engine.listener);sn1.sequencer.addEventListener( EffectEvent.EFFECT ,engine.listener);mj1.addEventListener("debug",_trace);engine.addEventListener("debug",_trace);phidget.addEventListener('debug',_trace);mj1.addEventListener("PalEvent",palEventHandler);function palEventHandler(e:PalEvent) {
	if(e.data.type == 'litChange') {
		engine.aTubeToggles[e.data.key] = e.data.value;
	}	
}//------------------------------------------------------// SEQUENCER CONTROLSfunction setBrightness(v:Number):void {	controlWrapper.volumeLabel.text = v;	phidget.globalBrightness = v;	sn1.globalBrightness = v;	mj1.globalBrightness = v;}function brightnessHandler(event:Event):void {	setBrightness(event.value);}controlWrapper.brightnessSlider.addEventListener(SliderEvent.CHANGE, brightnessHandler);function speedHandler(e:SliderEvent):int {	engine.speed = e.value;	controlWrapper.speedLabel.text = e.value;}function speedInputHandler(e:Event):int {	//trace(e);	engine.speed = e.value;	controlWrapper.speedSlider.value = e.value;}controlWrapper.speedSlider.addEventListener(SliderEvent.CHANGE, speedHandler);controlWrapper.speedLabel.text = globalSpeed;engine.trail = sn1.trailControl.value;function blackHandler(e:Event):void {	engine.blackout();	phidget.blackout();}
mj1.sequencer.addEventListener("blackout",blackHandler);sn1.sequencer.addEventListener("blackout",blackHandler);mj1.addEventListener("change",parameterHandler);
function parameterHandler(e:Event):void {	engine.loop = sn1.loopControl.selected;	engine.reflect = sn1.reflectControl.selected;	engine.reverse = sn1.reverseControl.selected;	engine.trail = sn1.trailControl.value;	engine.mj1Loop = mj1.cbLoop.selected;	engine.mj1Reflect = mj1.cbReflect.selected;	engine.mj1Reverse = mj1.cbReverse.selected;	engine.colorShift.on = mj1.cbColorShift.selected;
	engine.colorShift.inc = mj1.nsColorSpeed.value;
	engine.colorShift.update(mj1.aColorShift);
}function playerHandler(e:Event) {	switch(e.target.name) {		case "playButton":			if(!sn1.sequencer.hasItems())				return;			sn1.sequencer.go(true);			controlWrapper.playButton.visible = false;		break;		case "stopButton":			sn1.sequencer.go(false);			controlWrapper.playButton.visible = true;		break;		case "backButton":			sn1.sequencer.go();		break;		case "nextButton":			sn1.sequencer.stepper();		break;	}}controlWrapper.playButton.addEventListener(MouseEvent.CLICK,playerHandler);controlWrapper.stopButton.addEventListener(MouseEvent.CLICK,playerHandler);controlWrapper.backButton.addEventListener(MouseEvent.CLICK,playerHandler);controlWrapper.nextButton.addEventListener(MouseEvent.CLICK,playerHandler);//------------------------------------------------------//SEQUENCER/*var console:MovieClip = new MovieClip();	console.x = 5;	console.y = 315;addChild(console);*/var fxFactory:EffectFactory = new EffectFactory();for(var e in fxFactory.library) {	fxFactory.library[e].addEventListener( EffectEvent.EFFECT, engine.listener);	fxFactory.library[e].addEventListener( EffectEvent.EFFECT, getChildByName(fxFactory.library[e].device).sequencer.listener);}
var j = 0;for(var effectName in fxFactory.library) {	var effect:Effect = fxFactory.library[effectName];	if(!effect.channel)		continue;	var channel:Channel = new Channel(effect, effect.hotKey);		channel.x = 0;		channel.y = (j*45)+30;		channel.addEventListener( EffectEvent.EFFECT, engine.listener);		channel.addEventListener( EffectEvent.EFFECT, getChildByName(effect.device).sequencer.listener);//		channel.addEventListener( EffectEvent.CHANGED, fxFactory.listener);	sequencerWrapper.addChild(channel);	getChildByName(effect.device).sequencer.addEventListener( EffectEvent.EFFECT ,channel.queueHandler);	j++;}//------------------------------------------------------sequencerWrapper.visible = false;// /EFFECTS SEQUENCER //------------------------------------------------------function tabHandler(e:MouseEvent) {	sequencerWrapper.visible = !sequencerWrapper.visible;	mj1.visible = !sequencerWrapper.visible;	sn1.height *= (!sequencerWrapper.visible) ? 3 : .3333;	sn1.width *= (!sequencerWrapper.visible) ? 3 : .3333;	sn1.x = (!sequencerWrapper.visible) ? 600 : 800;	sn1.y = (!sequencerWrapper.visible) ? 0 : -20;}

var uiTab:Button = new Button();	uiTab.setSize(80,40);	uiTab.move(944,0);	uiTab.label = "Sequencer (\\)";	uiTab.addEventListener(MouseEvent.MOUSE_DOWN,tabHandler);addChild(uiTab);//------------------------------------------------------// KEYBOARD HANDLERfunction reportKeyDown(event:KeyboardEvent):void { 	var key = String.fromCharCode(event.charCode);		switch (event.keyCode) {	case Keyboard.LEFT:		key = "LEFT";	break;	case Keyboard.RIGHT:		key = "RIGHT";	break;	case Keyboard.UP:		key = "UP";	break;	case Keyboard.DOWN:		key = "DOWN";	break;	}	switch(key) {	case " ":		//sequencer.go();	break;	case "<":		engine.go(engine.fx);	break;	case ">":		//sequencer.stepper();	break;	case "M":		mj1.cbSyncBanks.selected = !mj1.cbSyncBanks.selected;	break;	case "L":		engine.mj1Loop = mj1.cbLoop.selected = !mj1.cbLoop.selected;	break;	case "K":		engine.mj1Reflect = mj1.cbReflect.selected = !mj1.cbReflect.selected;	break;	case 'J':		engine.mj1Reverse = mj1.cbReverse.selected = !mj1.cbReverse.selected;	break;	case "l":		engine.loop = sn1.loopControl.selected = !engine.loop;	break;	case "k":		engine.reflect = sn1.reflectControl.selected = !engine.reflect;	break;	case "j":		engine.reverse = sn1.reverseControl.selected = !engine.reverse;	break;	case "\\":		tabHandler(new MouseEvent(MouseEvent.CLICK));	break;
	/*	case "q":	case "w":	case "e":	case "r":	case "t":	case "y":	case "u":	case "i":	case "o":	case "p":
	*/	case "Q":	case "W":	case "E":	case "R":	case "T":	case "Y":	case "U":	case "I":	case "O":		if(fxFactory.hotKeysMap[key]) {			fxFactory.hotKeysMap[key].go();		}	break;	case "b":		engine.go(fxFactory.make("discoball"));	break;	case "m":		engine.go(fxFactory.make("strobe"));	break;	case "-":	case "_":	case "LEFT":
		engine.speed -= 5;		engine.speed = engine.speed - (engine.speed%5);		controlWrapper.speedLabel.text = engine.speed;		controlWrapper.speedSlider.value = engine.speed;	break;	case "=":	case "+":	case "RIGHT":		engine.speed += 5;		engine.speed -= (engine.speed%5);		controlWrapper.speedLabel.text = engine.speed;		controlWrapper.speedSlider.value = engine.speed;	break;	case "1":	case "2":	case "3":	case "4":	case "5":	case "6":	case "7":	case "8":	case "9":		controlWrapper.brightnessSlider.value = key * 10;		setBrightness(controlWrapper.brightnessSlider.value);	break;	case "`":		controlWrapper.brightnessSlider.value = 0;		setBrightness(controlWrapper.brightnessSlider.value);	break;	case "0":		controlWrapper.brightnessSlider.value = 100;		setBrightness(controlWrapper.brightnessSlider.value);	break;	case "UP":		controlWrapper.brightnessSlider.value += 2;		setBrightness(controlWrapper.brightnessSlider.value);	break;	case "DOWN":		controlWrapper.brightnessSlider.value -= 2;		setBrightness(controlWrapper.brightnessSlider.value);	break;	default:		_trace("Key Pressed: " + key + " (" + event.keyCode + " / " + event.charCode + ")"); 	break;	}} stage.addEventListener(KeyboardEvent.KEY_DOWN, reportKeyDown);import com.flashdynamix.utils.SWFProfiler;SWFProfiler.init(stage, this);/*var deviceArray:Array = Microphone.names; trace("Available sound input devices:"); for (var i:int = 0; i < deviceArray.length; i++) {     trace(" " + deviceArray[i]); }var mic:Microphone = Microphone.getMicrophone();mic.gain = 60;mic.rate = 11; mic.setUseEchoSuppression(true); mic.setLoopBack(true); mic.setSilenceLevel(50, 10); var micDetails:String = "Sound input device name: " + mic.name + '\n'; micDetails += "Gain: " + mic.gain + '\n'; micDetails += "Rate: " + mic.rate + " kHz" + '\n'; micDetails += "Muted: " + mic.muted + '\n'; micDetails += "Silence level: " + mic.silenceLevel + '\n'; micDetails += "Silence timeout: " + mic.silenceTimeout + '\n'; micDetails += "Echo suppression: " + mic.useEchoSuppression + '\n'; _trace(micDetails); mic.addEventListener(ActivityEvent.ACTIVITY, this.onMicActivity); function onMicActivity(event:ActivityEvent):void {     _trace("activating=" + event.activating + ", activityLevel=" +          mic.activityLevel); } mic.addEventListener(StatusEvent.STATUS, this.onMicStatus); function onMicStatus(event:StatusEvent):void {     if (event.code == "Microphone.Unmuted")     {         _trace("Microphone access was allowed.");     }      else if (event.code == "Microphone.Muted")     {          _trace("Microphone access was denied.");     } }*/