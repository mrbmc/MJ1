package com.whtn {	import com.whtn.Effect;	import com.whtn.EffectEvent;	import flash.events.Event;	import flash.events.EventDispatcher;	public class Sequencer extends EventDispatcher {		private var _queue:Array = new Array(8);		private var _current:int = 0;		private var _playing:Boolean = false;		public function Sequencer() {		}		public function listener(e:Event) {			switch(e.action) {				case EffectEvent.QUEUE_ADD:					this.queue_add(e.effect,e.effectName);				break;				case EffectEvent.QUEUE_DROP:					this.queue_drop(e.effectName);				break;				case EffectEvent.COMPLETED:					trace(">>>>>>>>>> " + EffectEvent.COMPLETED);					if(!hasItems()) {						dispatchEvent(new Event("blackout"));					}					return this.stepper();				break;			}		}		public function queue_drop (idx:int) {			_queue[idx] = null;			dispatchEvent(new EffectEvent(EffectEvent.QUEUE_CHANGE,null,_queue));			return hasItems();		}		public function queue_add (fx:Effect=null,idx:int=-1) {			var k = idx-1;			if(fx == _queue[k])				_queue[k] = null;			else				_queue[k] = fx;			dispatchEvent(new EffectEvent(EffectEvent.QUEUE_CHANGE,null,_queue));			return hasItems();		}		private function isNull (obj:Object,index:int,array:Array):Boolean {			return (obj==null);		};	 	public function go(_play:Object=null) {			if(!hasItems())				return;			_playing = (_play===true || _play===false) ? _play : !_playing;			if(_playing) {				if(_queue[_current]!=null) {					dispatchEvent(new EffectEvent(EffectEvent.PLAY,_queue[_current]));				}			} else {					dispatchEvent(new EffectEvent(EffectEvent.STOP));			}		}		public function stepper () {			i=0;			_current++;			while(_queue[_current]==null && i<_queue.length) {				_current++;				if(_current>=_queue.length)					_current=0;				i++;			}			if(_queue[_current]!=null && _playing) {				dispatchEvent(new EffectEvent(EffectEvent.PLAY,_queue[_current]));			}		}		public function hasItems() {			return !_queue.every(isNull);		}	}}