package com.wcp {	import com.phidgets.Phidget;	import com.phidgets.PhidgetLED;	import com.phidgets.PhidgetServo;	import com.phidgets.events.*;	import com.wcp.DebugEvent;	import flash.events.Event;	import flash.display.Sprite;	public class Phidgets extends Sprite {		//our devices		private var ceiling:PhidgetLED = new PhidgetLED();		private var wallLed:PhidgetLED = new PhidgetLED();		private var wallServoL:PhidgetServo = new PhidgetServo();		private var wallServoR:PhidgetServo = new PhidgetServo();		//Archives stores the last animation frame. Used to prevent repeat commands.		private var aLightArchive = new Array(64);		private var aTubeArchive = new Array(16);		//Animation defaults		public var globalBrightness:Number = 100;		protected var nServoResetPosition:Number = 90;		public function Phidgets ():void {			initPhidget(ceiling);			initPhidget(wallLed,115226);			initPhidget(wallServoL);			initPhidget(wallServoR);			for(i=0;i<60;i++){				aLightArchive[i] = (0);			}		}		private function _trace (o:Object):void {			dispatchEvent(new DebugEvent(o));		}				private function initPhidget(p:Phidget,serial:int=0x7FFFFFFF):void {			p.addEventListener(PhidgetEvent.CONNECT, this.onConnect);			p.addEventListener(PhidgetEvent.DETACH,	this.onDetach);			p.addEventListener(PhidgetEvent.ATTACH,	this.onAttach);			p.addEventListener(PhidgetErrorEvent.ERROR, this.onError);			p.open("localhost", 5001, null, serial);		}		private function onConnect(e:PhidgetEvent):void {			_trace(e + " to webservice");		}		private function onAttach(e:PhidgetEvent):void {			_trace(e.Device.Name + 				   ":" + e.Device.Type + 				   " serial# " + e.Device.serialNumber + 				   " v" + e.Device.Version				   );			if(e.Device.Type == "PhidgetLED") {				/*				UV: 3.5v (max 4.1) / < 350mA				WHITE: 3.3v (max 3.8) / < 30mA				*/				p.CurrentLimit = 1;				p.Voltage = 2.0;				_trace("current:"+p.CurrentLimit + " / voltage:"+p.Voltage);			} else if (e.Device.Type == "PhidgetServo") {				p.setPosition(0,nServoResetPosition);				_trace("position:" + p.getPosition);			}		}		private function onDetach(e:PhidgetEvent):void {			_trace(e);		}				private function onError(e:PhidgetErrorEvent):void {		//	if(e.indexOf("400")<=0)		//		trace(e);		}				public function sn1 (e:LightEvent):void {			var _brightness:int = 0;			if(e.display!=null){				for(i in e.display) {					_brightness = (i<60) ? (e.display[i]/100*globalBrightness) : e.display[i];					if(aLightArchive[i] != _brightness || _brightness<=0)						ceiling.setDiscreteLED( i, _brightness );					aLightArchive[i]=_brightness;				}			} else {				_brightness = (e.index<60) ? (e.brightness/100*globalBrightness) : e.brightness;				ceiling.setDiscreteLED( e.index, _brightness );				aLightArchive[e.index] = _brightness;			}			return;		}		private function updateMJ1 (i,o:Object) {			_brightness = (i<48) ? (o.brightness / 100 * globalBrightness) : o.brightness;			//optimize events sent to phidgets by not sending dupes			if(aTubeArchive[i] != _brightness || _brightness<=0) {				//prepare color				var rgb = Drawing.hex2rgb(o.color);				var ii = i*3;				wallLed.setDiscreteLED( ii, (rgb.r/255) * _brightness);				wallLed.setDiscreteLED( ii+1, (rgb.g/255) * _brightness);				wallLed.setDiscreteLED( ii+2, (rgb.b/255) * _brightness);				//servo update				if(i < 8)					if(wallServoL.isAttached) wallServoL.setPosition( i, o.rotation );				else					if(wallServoR.isAttached) wallServoR.setPosition( i, o.rotation );//				trace("tube:"+i+"("+rgb.r+","+rgb.g+","+rgb.b+") / " + o.rotation);			}			aTubeArchive[i]=_brightness;		}		public function MJ1 (e:TubeEvent):void {			//_trace(e.index+":"+e.brightness+":"+e.color);			if(e.display!=null){				for(i in e.display) {					updateMJ1(i,e.display[i]);				}			} else {				updateMJ1(e.index,e);			}		}				public function blackout() {			for(i=0;i<64;i++) {				ceiling.setDiscreteLED( i, 0 );			}			for(i=0;i<48;i++) {				wallLed.setDiscreteLED( i, 0 );			}			for(i=0;i<16;i++) {				if(i<8) {					//wallServoL.setPosition( i, nServoResetPosition );				} else {					//wallServoR.setPosition( i, nServoResetPosition );				}			}		}				public function listener (e:Event) {			if(e is TubeEvent) {				this.MJ1(e);			} else if (e is LightEvent) {				this.sn1(e);			}		}	}}